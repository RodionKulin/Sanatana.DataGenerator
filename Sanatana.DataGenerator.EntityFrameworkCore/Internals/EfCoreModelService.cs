using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;

namespace Sanatana.DataGenerator.EntityFrameworkCore.Internals
{
    public class EfCoreModelService
    {
        private readonly Func<DbContext> _dbContextFactory;


        //init
        public EfCoreModelService(Func<DbContext> dbContextFactory)
        {
            _dbContextFactory = dbContextFactory ?? throw new ArgumentNullException(nameof(dbContextFactory));
        }


        //methods
        public virtual Type[] GetConfiguredEntities()
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                IEnumerable<IEntityType> efEntityTypes = dbContext.Model.GetEntityTypes();
                return efEntityTypes.Select(x => x.ClrType).ToArray();
            }
        }

        public virtual bool CheckHasAutoGeneratedProperties(Type typeToCheck)
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                IEntityType efEntityType = dbContext.Model.FindEntityType(typeToCheck);

                IEnumerable<IProperty> keyProperties = efEntityType.GetProperties();
                keyProperties = keyProperties.Where(x => x.ValueGenerated != ValueGenerated.OnAdd
                    || x.ValueGenerated == ValueGenerated.OnAddOrUpdate);
                return keyProperties.Any();
            }
        }

        public virtual Type[] GetParentEntities(Type typeToCheck)
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                IEntityType efEntityType = dbContext.Model.FindEntityType(typeToCheck);
                IForeignKey[] foreignKeys = efEntityType.GetForeignKeys().ToArray();
                return foreignKeys
                    .Select(x => x.PrincipalEntityType.ClrType)
                    .Where(x => x != typeToCheck) //skip self reference by entity
                    .ToArray();
            }
        }

        public virtual PropertyInfo[] GetPrimaryKeysManuallyGenerated(Type typeToCheck)
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                IEntityType efEntityType = dbContext.Model.FindEntityType(typeToCheck);

                IEnumerable<IKey> keys = efEntityType.GetKeys();
                IEnumerable<IProperty> keyProperties = keys.SelectMany(x => x.Properties);
                keyProperties = keyProperties.Where(x => x.ValueGenerated == ValueGenerated.Never); //skip auto generated keys
                return keyProperties
                    .Select(x => x.PropertyInfo)
                    .Where(prop => prop != null)
                    .ToArray();
            }
        }

        public virtual PropertyInfo[] GetNavigationProperties(Type typeToCheck)
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                IEntityType efEntityType = dbContext.Model.FindEntityType(typeToCheck);
                INavigation[] navigationProps = efEntityType.GetNavigations().ToArray();
                return navigationProps
                    .Select(x => x.PropertyInfo)
                    .Where(prop => prop != null)
                    .ToArray();
            }
        }

        public virtual PropertyInfo[] GetSelfReferenceForeignKeys(Type typeToCheck)
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                IEntityType efEntityType = dbContext.Model.FindEntityType(typeToCheck);
                if(efEntityType == null)
                {
                    return new PropertyInfo[0];
                }

                IEnumerable<IForeignKey> foreignKeys = efEntityType.GetForeignKeys();
                IForeignKey[] foreignKeysToSelf = foreignKeys
                    .Where(x => x.PrincipalEntityType.ClrType == typeToCheck)
                    .ToArray();

#pragma warning disable CS8619 // Nullability of reference types in value doesn't match target type.
                return foreignKeysToSelf
                    .SelectMany(foreignKey => foreignKey.Properties)
                    .Select(property => property.PropertyInfo)
                    .Where(propertyInfo => propertyInfo != null) //it not have to be declared on child entity
                    .Distinct()
                    .ToArray();
#pragma warning restore CS8619
            }
        }

        public virtual void SetForeignKeysOnChild(object childInstance, object parentInstance)
        {
            using (DbContext dbContext = _dbContextFactory())
            {
                Type childType = childInstance.GetType();
                Type parentType = parentInstance.GetType();

                IEntityType efEntityType = dbContext.Model.FindEntityType(childType);

                IEnumerable<IForeignKey> foreignKeys = efEntityType.GetForeignKeys();
                IForeignKey[] foreignKeysToParent = foreignKeys
                    .Where(x => x.PrincipalEntityType.ClrType == parentType)
                    .ToArray();

                foreach (IForeignKey foreignKey in foreignKeysToParent)
                {
                    for (int i = 0; i < foreignKey.PrincipalKey.Properties.Count; i++)
                    {
                        PropertyInfo parentProp = foreignKey.PrincipalKey.Properties[i].PropertyInfo;
                        object foreignKeyValue = parentProp.GetValue(parentInstance);

                        PropertyInfo childProp = foreignKey.Properties[i].PropertyInfo;
                        if (childProp != null)
                        {
                            //child entity does not have to declare foreign key
                            childProp.SetValue(childInstance, foreignKeyValue);
                        }
                    }
                }
            }

        }

    }
}
